\documentclass{beamer}

\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{2218}{\ensuremath{\circ}}
\DeclareUnicodeCharacter{2192}{\ensuremath{\to}}
\DeclareUnicodeCharacter{2200}{\ensuremath{\forall}}
\DeclareUnicodeCharacter{1D52}{\ensuremath{{}^{\text{o}}}}
\DeclareUnicodeCharacter{1D56}{\ensuremath{{}^{\text{p}}}}
\DeclareUnicodeCharacter{03C6}{\ensuremath{\varphi}}
\DeclareUnicodeCharacter{03C8}{\ensuremath{\psi}}
\DeclareUnicodeCharacter{03B1}{\ensuremath{\alpha}}
\DeclareUnicodeCharacter{03B2}{\ensuremath{\beta}}
\DeclareUnicodeCharacter{03B3}{\ensuremath{\gamma}}
\DeclareUnicodeCharacter{03BB}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{0394}{\ensuremath{\Delta}}
\DeclareUnicodeCharacter{0280}{\ensuremath{{}_0}}
\DeclareUnicodeCharacter{0281}{\ensuremath{{}_1}}
\DeclareUnicodeCharacter{0282}{\ensuremath{{}_2}}
\DeclareUnicodeCharacter{1D30}{\ensuremath{{}^D}}
\DeclareUnicodeCharacter{21D2}{\ensuremath{\Rightarrow}}
\DeclareUnicodeCharacter{2115}{\ensuremath{\mathbb{N}}}

\usetheme{Copenhagen}
\usecolortheme{albatross}

\title{Jason Gross' Wishlist for Coq}
\date{POPL 2014 --- Coq Users Meeting}

\setlength{\parskip}{\baselineskip}

\begin{document}
\begin{frame}
\maketitle
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section{Higher Inductive Types}

\begin{frame}[fragile]{Higher Inductive Types}
  \Large
  Higher inductive types are: \pause
  \begin{itemize}
    \item Inductive types \pause
    \item freely generated with higher path structure (non-trivial equalities) \pause
  \end{itemize}
  
  Example: The interval ($0 \leadsto 1$) \pause
\begin{verbatim}
Inductive Interval :=
| zero : Interval
| one  : Interval
| seg  : zero = one. 
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Higher Inductive Types}{Why?}
  \Large
  Higher inductive types are useful for: \pause
  \begin{itemize}
    \item Homotopy type theory (making basic spaces)\pause
    \item Quotient types \pause
    \item Formalizing version control systems (according to Dan Licata\only<4->{\footnote{``Git as a HIT'', \url{http://dlicata.web.wesleyan.edu/pubs/l13git/git.pdf}}})
    \item Proving functional extensionality
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Higher Inductive Types}{Proving functional extensionality}
  \Large
\begin{verbatim}
Definition functional_extensionality A B f g
    (H : ∀ x, f x = g x ) → f = g
   := f_equal
       (λ i x ⇒
         match i return B with
           | zero ⇒ f x
           | one  ⇒ g x
           | seg  ⇒ H x
         end)
       seg.
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Higher Inductive Types}{Proving functional extensionality}
  \Large
\begin{verbatim}
   := match seg in (_ = y)
        return ((λ x ⇒ f x)
                = (λ x ⇒ match y with
                           | zero ⇒ f x
                           | one  ⇒ g x
                           | seg  ⇒ H x
                         end))
      with
        | eq_refl => eq_refl
      end.
\end{verbatim}
\end{frame}

\begin{frame}{Higher Inductive Types}{How?}
  \Large
  Note that higher inductive types don't magically give you computational functional extensionality. \pause
  
  You must solve computational functional extensionality to implement computational HITs. \pause
  
  (Similar story for implementing computational univalence, another feature on my wishlist.) \pause
  
  Breaks canonicity, \pause preserves canonicity up to propositional equality? (conjectured by Voevodsky for UA)
\end{frame}

\begin{frame}{Higher Inductive Types}{Current Work}
  \Large
  \begin{itemize}
    \item Yves Bertot's private inductive types;\footnote{\url{http://coq.inria.fr/files/coq5\_submission_3.pdf}} adapted by Matthieu Sozeau \pause
      \begin{itemize} \large
        \item Comparatively easy to implement \pause
        \item Allows one to disable pattern matching on inductive types outside a module, which is sufficient to implement a trick by Dan Licata\footnote<3->{\url{http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/}} \pause
        \item Equalities are axioms; not computational \pause
        \item Only eliminators, no pattern matching \pause
      \end{itemize}
    \item Burno Barras has some work that's more computational\footnote<6->{\url{https://github.com/barras/coq/tree/hit}}
  \end{itemize}
\end{frame}

\begin{frame}{Higher Inductive Types}{My Wishes}
  \Large
  I want: \pause
  \begin{itemize}
	\item to be able to define and pattern match on higher inductive types \pause
	\item all tactics should support HITs \pause
	\item judgmental reduction rules for matching on paths from HITs \pause
	\item equality should not be special \pause
	  \begin{itemize} \large
	    \item typechecker should not depend on standard library \pause
	    \item c.f. proposal for pattern matching justifying K\only<7->{\footnote{``The K axiom in Coq (almost) for free'' \url{http://coq.inria.fr/files/adt-2fev10-corbineau.pdf}}}
	  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Higher Inductive Types (without equality)}{Possible Generalization}
  \Large
\begin{verbatim}
Inductive _==_ {A} (x : A) : ∀ {B}, B → Type :=
| refl1 : x == x
| refl2 : x == x.
Inductive foo : Type :=
| bar : nat → foo
| proof1 : ∀ (n : ℕ), bar 2 == bar (S (S n))
| proof2 : ∀ (n : ℕ), bar 0 == bar 1
and picking
| proof1 : ∀ n, bar 2 == _ := λ n ⇒ refl1
| proof2 : ∀ n, bar 0 == _ := λ n ⇒ refl2.
\end{verbatim}
\end{frame}

\begin{frame}{The Rest of my Wishlist (I)}
This was just a small (but important) part of my wishlist.  The rest is:

\begin{itemize}
  \item
    a better story for namespacing\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3171}}
  \item
    irrelevant fields/a type of strict hProps/Coq*
  \item 
    built-in CoqMT
  \item 
    judgmental eta for the unit type
  \item 
    a search that searches the entire standard library, and not just currently \texttt{Require}d files
  \item 
    a search which is up to unification, rather than up to pattern matching
\end{itemize}
\end{frame}

\begin{frame}{The Rest of my Wishlist (II)}
\begin{itemize}
  \item 
    coercions which don't care about the uniform inheritance condition\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3115}}
  \item 
    built-in MTac or other monadic tactic language
  \item 
    better handling of open terms in Ltac, and support for recursing under binders in tactics (maybe fixed with new tactic engine?)\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3106} and \url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3102}}
  \item 
    easier use of ML plugins (I don't want to have to recompile them myself)
  \item 
    induction-recursion
  \item 
    more uniform support for canonical structures (like I've heard ssr has)
  \item 
    support for computational parametricity
\end{itemize}
\end{frame}

\begin{frame}{The Rest of my Wishlist (II)}
\begin{itemize}
  \item 
    better coinduction (should be compositional, maybe based on copatterns or something)
  \item 
    size/type-based termination
  \item 
    faster rewrite
  \item 
    support for reflective simplification (maybe a native reifier which runs at type inference time, and a special type in the stdlib or something for syntax)
  \item 
    automatic generation of the equivalence between record types and nested sigma types
  \item 
    ability to write theorems that apply to all records, which are specialized at type-inference time (a la typeclasses or mtac)
  \item 
    rewrite that alternates simpl and argument inference
  \item 
    rewrite which matches the head by pattern matching and the rest by unification
\end{itemize}
\end{frame}

\begin{frame}{The Rest of my Wishlist (III)}
\begin{itemize}
  \item 
    variant of @? patterns for [pattern]ing on things other than bound indices and parameters, heuristically\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3148}}
  \item 
    a variant of \texttt{Hint Rewrite} which infers arguments based on pattern matching then runs \texttt{simpl} on the hypothesis, then rewrites with the simplified hypothesis
  \item 
    'where' clauses in records should permit abbreviations\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3066}}
  \item 
    variant of \texttt{abstract} which finishes the subproof with \texttt{Defined} rather than \texttt{Qed} (and another variant which finishes it with \texttt{Defined} and then runs \texttt{Global Opaque} on the constant)
  \item 
    allow overriding symmetry, reflexivity\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3113}}
\end{itemize}
\end{frame}

\begin{frame}{The Rest of my Wishlist (IV)}
\begin{itemize}
  \item 
    etransitivity should take an optional term with holes\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3065}}
  \item 
    where clauses in records should support \texttt{(only parsing)}\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3067}}
  \item 
    support for simultaneous generation of terms binding scopes\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3123}}
  \item 
    have a \texttt{function\_scope} like \texttt{type\_scope}\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3080}}
  \item 
    judgmental eta for all inductive types\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3119}}
  \item 
    more judgmental commutation rules for \texttt{match}\footnote{\url{https://coq.inria.fr/bugs/show\_bug.cgi?id=3191} and related bugs}
  \item 
    support for computational higher inductive types
  \item 
    support for computational univalence
  \item 
    computational functional extensionality
  \item 
    better handling (speed-wise) of large terms and types (native projections might fix this)
  \item 
    support for explicit universe level variables (without loosing the default of typical ambiguity)
  \item 
    \texttt{eq\_sym (eq\_sym p)} should be judgmentally equal to \texttt{p}
  \item 
    setoid rewriting in \texttt{Type}
\end{itemize}
\end{frame}
\end{document}